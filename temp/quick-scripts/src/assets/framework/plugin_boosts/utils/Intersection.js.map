{"version":3,"sources":["assets\\framework\\plugin_boosts\\utils\\Intersection.ts"],"names":[],"mappings":";;;;;AAAA;IAAA;IAyBA,CAAC;IAvBG,wBAAwB;IACjB,gCAAmB,GAA1B,UAA2B,SAAiB,EAAE,MAAM,EAAE,IAAI;QACtD,IAAI,EAAE,GAAG,CAAC,CAAA;QACV,IAAI,EAAE,GAAG,CAAC,CAAA;QACV,yEAAyE;QACzE,IAAI,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;YACpB,EAAE,GAAG,IAAI,CAAC,CAAC,CAAA;aACV,IAAI,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK;YACtC,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAA;;YAExB,EAAE,GAAG,SAAS,CAAC,CAAC,CAAA;QACpB,IAAI,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;YACpB,EAAE,GAAG,IAAI,CAAC,CAAC,CAAA;aACV,IAAI,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM;YACvC,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAA;;YAEzB,EAAE,GAAG,SAAS,CAAC,CAAC,CAAA;QACpB,IAAI,EAAE,GAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAC,EAAE,CAAC,CAAA;QACpB,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,CAAA;QACrB,IAAI,EAAE,CAAC,MAAM,EAAE,GAAG,MAAM,GAAG,MAAM;YAC7B,OAAO,IAAI,CAAA;QACf,OAAO,KAAK,CAAA;IAChB,CAAC;IACL,mBAAC;AAAD,CAzBA,AAyBC,IAAA;;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiMG","file":"","sourceRoot":"/","sourcesContent":["export default class Intersection\r\n{\r\n    // contains and intesect\r\n    static circleIntersectRect(circle_pt:cc.Vec2, radius, rect){\r\n        let cx = 0\r\n        let cy = 0\r\n        //Find the point on the collision box closest to the center of the circle\r\n        if (circle_pt.x < rect.x)\r\n            cx = rect.x\r\n        else if (circle_pt.x > rect.x + rect.width)\r\n            cx = rect.x + rect.width\r\n        else\r\n            cx = circle_pt.x\r\n        if (circle_pt.y < rect.y )\r\n            cy = rect.y\r\n        else if( circle_pt.y > rect.y + rect.height)\r\n            cy = rect.y + rect.height\r\n        else\r\n            cy = circle_pt.y\r\n        let v2 =cc.v2(cx,cy) \r\n        v2.subSelf(circle_pt)    \r\n        if (v2.magSqr() < radius * radius)\r\n            return true\r\n        return false\r\n    }\r\n}\r\n/***\r\n// 矩形和圆形碰撞检测\r\nbool IsCirlceCollisionRect(float circleXPos, float circleYPos, float radius, float rectX, float rectY, float rectW, float rectH)\r\n{\r\n    float arcR  = radius;\r\n    float arcOx = circleXPos;\r\n    float arcOy = circleYPos;\r\n\r\n    //分别判断矩形4个顶点与圆心的距离是否<=圆半径；如果<=，说明碰撞成功   \r\n    if(((rectX-arcOx) * (rectX-arcOx) + (rectY-arcOy) * (rectY-arcOy)) <= arcR * arcR)   \r\n        return true;   \r\n    if(((rectX+rectW-arcOx) * (rectX+rectW-arcOx) + (rectY-arcOy) * (rectY-arcOy)) <= arcR * arcR)   \r\n        return true;   \r\n    if(((rectX-arcOx) * (rectX-arcOx) + (rectY+rectH-arcOy) * (rectY+rectH-arcOy)) <= arcR * arcR)   \r\n        return true;   \r\n    if(((rectX+rectW-arcOx) * (rectX+rectW-arcOx) + (rectY+rectH-arcOy) * (rectY+rectH-arcOy)) <= arcR * arcR)   \r\n        return true;\r\n\r\n    //判断当圆心的Y坐标进入矩形内时X的位置，如果X在(rectX-arcR)到(rectX+rectW+arcR)这个范围内，则碰撞成功   \r\n    float minDisX = 0;   \r\n    if(arcOy >= rectY && arcOy <= rectY + rectH)\r\n    {   \r\n        if(arcOx < rectX)   \r\n            minDisX = rectX - arcOx;   \r\n        else if(arcOx > rectX + rectW)   \r\n            minDisX = arcOx - rectX - rectW;   \r\n        else    \r\n            return true;   \r\n        if(minDisX <= arcR)   \r\n            return true;   \r\n    }\r\n\r\n    //判断当圆心的X坐标进入矩形内时Y的位置，如果X在(rectY-arcR)到(rectY+rectH+arcR)这个范围内，则碰撞成功\r\n    float minDisY = 0;   \r\n    if(arcOx >= rectX && arcOx <= rectX + rectW)\r\n    {   \r\n        if(arcOy < rectY)   \r\n            minDisY = rectY - arcOy;   \r\n        else if(arcOy > rectY + rectH)   \r\n            minDisY = arcOy - rectY - rectH;   \r\n        else  \r\n            return true;   \r\n        if(minDisY <= arcR)   \r\n            return true;   \r\n    }\r\n\r\n    return false; \r\n}\r\n\r\n// 线段和线段碰撞检测\r\nbool IsLineCollisionLine(cocos2d::CCPoint p1, cocos2d::CCPoint p2, cocos2d::CCPoint p3, cocos2d::CCPoint p4)\r\n{\r\n    float x1 = p1.x, x2 = p2.x, x3 = p3.x, x4 = p4.x;\r\n    float y1 = p1.y, y2 = p2.y, y3 = p3.y, y4 = p4.y;\r\n\r\n    float d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n    // If d is zero, there is no intersection\r\n    if (d == 0) \r\n        return false;\r\n\r\n    // Get the x and y\r\n    float pre = (x1*y2 - y1*x2), post = (x3*y4 - y3*x4);\r\n    float x = ( pre * (x3 - x4) - (x1 - x2) * post ) / d;\r\n    float y = ( pre * (y3 - y4) - (y1 - y2) * post ) / d;\r\n\r\n    // Check if the x and y coordinates are within both lines\r\n    if ( x < MIN(x1, x2) || x > MAX(x1, x2) ||\r\n        x < MIN(x3, x4) || x > MAX(x3, x4) )\r\n        return false;\r\n\r\n    if ( y < MIN(y1, y2) || y > MAX(y1, y2) ||\r\n        y < MIN(y3, y4) || y > MAX(y3, y4) ) \r\n        return false;\r\n\r\n    return true;\r\n}\r\n\r\nstatic float mult(cocos2d::CCPoint a, cocos2d::CCPoint b, cocos2d::CCPoint c)\r\n{\r\n    return (a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y);\r\n}\r\n\r\nbool IsLineCollisionLine2(cocos2d::CCPoint aa, cocos2d::CCPoint bb, cocos2d::CCPoint cc, cocos2d::CCPoint dd)\r\n{\r\n    if ( MAX(aa.x, bb.x)<MIN(cc.x, dd.x) )\r\n        return false;\r\n\r\n    if ( MAX(aa.y, bb.y)<MIN(cc.y, dd.y) )\r\n        return false;\r\n\r\n    if ( MAX(cc.x, dd.x)<MIN(aa.x, bb.x) )\r\n        return false;\r\n\r\n    if ( MAX(cc.y, dd.y)<MIN(aa.y, bb.y) )\r\n        return false;\r\n\r\n    if (mult(cc, bb, aa)*mult(bb, dd, aa)<0.0001f)\r\n        return false;\r\n\r\n    if (mult(aa, dd, cc)*mult(dd, bb, cc)<0.0001f)\r\n        return false;\r\n\r\n    return true;\r\n}\r\n\r\n// 线段和矩形碰撞检测\r\nbool IsLineCollisionRect(cocos2d::CCPoint lineStartPoint, cocos2d::CCPoint lineEndPoint, cocos2d::CCPoint rectleftBottomPoint, float width, float height)\r\n{\r\n    // 因为这个方法专门进行射线光束的碰撞检测，所以暂不进行线段在矩形内的碰撞检测\r\n    cocos2d::CCPoint leftLineStartPoint = rectleftBottomPoint;\r\n    cocos2d::CCPoint leftLineEndPoint   = cocos2d::CCPoint(leftLineStartPoint.x, leftLineStartPoint.y+height);\r\n\r\n    cocos2d::CCPoint rightLineStartPoint= cocos2d::CCPoint(leftLineStartPoint.x+width, leftLineStartPoint.y);\r\n    cocos2d::CCPoint rightLineEndPoint  = cocos2d::CCPoint(leftLineStartPoint.x+width, leftLineStartPoint.y+height);\r\n\r\n    cocos2d::CCPoint topLineStartPoint  = cocos2d::CCPoint(leftLineStartPoint.x, leftLineStartPoint.y+height);\r\n    cocos2d::CCPoint topLineEndPoint    = cocos2d::CCPoint(leftLineStartPoint.x+width, leftLineStartPoint.y+height);\r\n\r\n    cocos2d::CCPoint bottomLineStartPoint= cocos2d::CCPoint(leftLineStartPoint.x, leftLineStartPoint.y);\r\n    cocos2d::CCPoint bottomLineEndPoint  = cocos2d::CCPoint(leftLineStartPoint.x+width, leftLineStartPoint.y);\r\n    \r\n    cocos2d::CCPoint leftBottomLineStartPoint= rectleftBottomPoint;\r\n    cocos2d::CCPoint rightTopLineEndPoint    = rightLineEndPoint;\r\n\r\n    cocos2d::CCPoint leftTopLineStartPoint   = leftLineEndPoint;\r\n    cocos2d::CCPoint rightBottomLineEndPoint = rightLineStartPoint;\r\n\r\n\r\n    do \r\n    {\r\n        if (IsLineCollisionLine2(lineStartPoint, lineEndPoint, leftLineStartPoint, leftLineEndPoint))\r\n            break;\r\n\r\n        if (IsLineCollisionLine2(lineStartPoint, lineEndPoint, rightLineStartPoint, rightLineEndPoint))\r\n            break;\r\n\r\n        if (IsLineCollisionLine2(lineStartPoint, lineEndPoint, topLineStartPoint, topLineEndPoint))\r\n            break;\r\n\r\n        if (IsLineCollisionLine2(lineStartPoint, lineEndPoint, bottomLineStartPoint, bottomLineEndPoint))\r\n            break;\r\n\r\n        if (IsLineCollisionLine2(lineStartPoint, lineEndPoint, leftBottomLineStartPoint, rightTopLineEndPoint))\r\n            break;\r\n\r\n        if (IsLineCollisionLine2(lineStartPoint, lineEndPoint, leftTopLineStartPoint, rightBottomLineEndPoint))\r\n            break;\r\n\r\n        return false;\r\n    } \r\n    while (false);\r\n\r\n    return true;\r\n}\r\n\r\nstatic  bool  IsRectCollisionRect2(cocos2d::CCPoint rect1CenterPoint, float rect1W, float rect1H, cocos2d::CCPoint rect2CenterPoint, float rect2W, float rect2H)\r\n{\r\n    cocos2d::CCPoint leftTopPoint     = cocos2d::CCPoint(rect2CenterPoint.x-rect2W/2.0f, rect2CenterPoint.y+rect2H/2.0f);\r\n    cocos2d::CCPoint leftBottomPoint  = cocos2d::CCPoint(rect2CenterPoint.x-rect2W/2.0f, rect2CenterPoint.y-rect2H/2.0f);\r\n    cocos2d::CCPoint rightTopPoint    = cocos2d::CCPoint(rect2CenterPoint.x+rect2W/2.0f, rect2CenterPoint.y+rect2H/2.0f);\r\n    cocos2d::CCPoint rightBottomPoint = cocos2d::CCPoint(rect2CenterPoint.x+rect2W/2.0f, rect2CenterPoint.y-rect2H/2.0f);\r\n\r\n    if ( (leftTopPoint.x>(rect1CenterPoint.x-rect1W/2.0f)) && (leftTopPoint.x<(rect1CenterPoint.x+rect1W/2.0f)) \r\n        && (leftTopPoint.y>(rect1CenterPoint.y-rect1H/2.0f)) && (leftTopPoint.y<(rect1CenterPoint.y+rect1H/2.0f)))\r\n        return true;\r\n\r\n    if ( (leftBottomPoint.x>(rect1CenterPoint.x-rect1W/2.0f)) && (leftBottomPoint.x<(rect1CenterPoint.x+rect1W/2.0f)) \r\n        && (leftBottomPoint.y>(rect1CenterPoint.y-rect1H/2.0f)) && (leftBottomPoint.y<(rect1CenterPoint.y+rect1H/2.0f)))\r\n        return true;\r\n\r\n    if ( (rightTopPoint.x>(rect1CenterPoint.x-rect1W/2.0f)) && (rightTopPoint.x<(rect1CenterPoint.x+rect1W/2.0f)) \r\n        && (rightTopPoint.y>(rect1CenterPoint.y-rect1H/2.0f)) && (rightTopPoint.y<(rect1CenterPoint.y+rect1H/2.0f)))\r\n        return true;\r\n\r\n    if ( (rightBottomPoint.x>(rect1CenterPoint.x-rect1W/2.0f)) && (rightBottomPoint.x<(rect1CenterPoint.x+rect1W/2.0f)) \r\n        && (rightBottomPoint.y>(rect1CenterPoint.y-rect1H/2.0f)) && (rightBottomPoint.y<(rect1CenterPoint.y+rect1H/2.0f)))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n\r\n// 矩形和矩形碰撞检测\r\nbool  IsRectCollisionRect(cocos2d::CCPoint rect1CenterPoint, float rect1W, float rect1H, cocos2d::CCPoint rect2CenterPoint, float rect2W, float rect2H)\r\n{\r\n    if (IsRectCollisionRect2(rect1CenterPoint, rect1W, rect1H, rect2CenterPoint, rect2W, rect2H))\r\n        return true;\r\n    \r\n    if (IsRectCollisionRect2(rect2CenterPoint, rect2W, rect2H, rect1CenterPoint, rect1W, rect1H))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n\r\n**/"]}