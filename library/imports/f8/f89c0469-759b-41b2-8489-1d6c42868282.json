{
  "__type__": "cc.TextAsset",
  "_name": "flatbuffers.d",
  "_objFlags": 0,
  "_native": "",
  "text": "declare module flatbuffers {\r\n  /**\r\n   * @typedef {number}\r\n   */\r\n  export type Offset = number;\r\n\r\n  /**\r\n   * @typedef {{\r\n   *   bb: flatbuffers.ByteBuffer,\r\n   *   bb_pos: number\r\n   * }}\r\n   */\r\n  export interface Table {\r\n    bb: ByteBuffer;\r\n    bb_pos: number;\r\n  }\r\n\r\n  /**\r\n   * @type {number}\r\n   * @const\r\n   */\r\n  export const SIZEOF_SHORT: number;\r\n\r\n  /**\r\n   * @type {number}\r\n   * @const\r\n   */\r\n  export const SIZEOF_INT: number;\r\n\r\n  /**\r\n   * @type {number}\r\n   * @const\r\n   */\r\n  export const FILE_IDENTIFIER_LENGTH: number;\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  export enum Encoding { UTF8_BYTES, UTF16_STRING }\r\n\r\n  /**\r\n   * @type {Int32Array}\r\n   * @const\r\n   */\r\n  export var int32: Int32Array;\r\n\r\n  /**\r\n   * @type {Float32Array}\r\n   * @const\r\n   */\r\n  export var float32: Float32Array;\r\n\r\n  /**\r\n   * @type {Float64Array}\r\n   * @const\r\n   */\r\n  export var float64: Float64Array;\r\n\r\n  /**\r\n   * @type {boolean}\r\n   * @const\r\n   */\r\n  export var isLittleEndian: boolean;\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  export class Long {\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     */\r\n    public low: number;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     */\r\n    public high: number;\r\n\r\n    /**\r\n     * @type {flatbuffers.Long}\r\n     * @const\r\n     */\r\n    static ZERO: Long;\r\n\r\n    /**\r\n     * @constructor\r\n     * @param {number} high\r\n     * @param {number} low\r\n     */\r\n    constructor(low: number, high: number);\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    toFloat64(): number;\r\n\r\n    /**\r\n     * @param {flatbuffers.Long} other\r\n     * @returns {boolean}\r\n     */\r\n    equals(other): boolean;\r\n  }\r\n\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n\r\n  export class Builder {\r\n\r\n    /**\r\n     * @constructor\r\n     * @param {number=} initial_size\r\n     */\r\n    constructor(initial_size?: number);\r\n\r\n    /**\r\n     * In order to save space, fields that are set to their default value\r\n     * don't get serialized into the buffer. Forcing defaults provides a\r\n     * way to manually disable this optimization.\r\n     *\r\n     * @param {boolean} forceDefaults true always serializes default values\r\n     */\r\n    forceDefaults(forceDefaults: boolean): void;\r\n\r\n    /**\r\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\r\n     * called finish(). The actual data starts at the ByteBuffer's current position,\r\n     * not necessarily at 0.\r\n     *\r\n     * @returns {flatbuffers.ByteBuffer}\r\n     */\r\n    dataBuffer(): ByteBuffer;\r\n\r\n    /**\r\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\r\n     * called finish(). The actual data starts at the ByteBuffer's current position,\r\n     * not necessarily at 0.\r\n     *\r\n     * @returns {Uint8Array}\r\n     */\r\n    asUint8Array(): Uint8Array;\r\n\r\n    /**\r\n     * Prepare to write an element of `size` after `additional_bytes` have been\r\n     * written, e.g. if you write a string, you need to align such the int length\r\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\r\n     * you need to do is alignment, `additional_bytes` will be 0.\r\n     *\r\n     * @param {number} size This is the of the new element to write\r\n     * @param {number} additional_bytes The padding size\r\n     */\r\n    prep(size: number, additional_bytes: number): void;\r\n\r\n    /**\r\n     * @param {number} byte_size\r\n     */\r\n    pad(byte_size: number): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    writeInt8(value: number): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    writeInt16(value: number): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    writeInt32(value: number): void;\r\n\r\n    /**\r\n     * @param {flatbuffers.Long} value\r\n     */\r\n    writeInt64(value: Long): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    writeFloat32(value: number): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    writeFloat64(value: number): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    addInt8(value: number): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    addInt16(value: number): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    addInt32(value: number): void;\r\n\r\n    /**\r\n     * @param {flatbuffers.Long} value\r\n     */\r\n    addInt64(value: Long): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    addFloat32(value: number): void;\r\n\r\n    /**\r\n     * @param {number} value\r\n     */\r\n    addFloat64(value: number): void;\r\n\r\n    /**\r\n     * @param {number} voffset\r\n     * @param {number} value\r\n     * @param {number} defaultValue\r\n     */\r\n    addFieldInt8(voffset: number, value: number, defaultValue: number): void;\r\n\r\n    /**\r\n     * @param {number} voffset\r\n     * @param {number} value\r\n     * @param {number} defaultValue\r\n     */\r\n    addFieldInt16(voffset: number, value: number, defaultValue: number): void;\r\n\r\n    /**\r\n     * @param {number} voffset\r\n     * @param {number} value\r\n     * @param {number} defaultValue\r\n     */\r\n    addFieldInt32(voffset: number, value: number, defaultValue: number): void;\r\n\r\n    /**\r\n     * @param {number} voffset\r\n     * @param {flatbuffers.Long} value\r\n     * @param {flatbuffers.Long} defaultValue\r\n     */\r\n    addFieldInt64(voffset: number, value: Long, defaultValue: Long): void;\r\n\r\n    /**\r\n     * @param {number} voffset\r\n     * @param {number} value\r\n     * @param {number} defaultValue\r\n     */\r\n    addFieldFloat32(voffset: number, value: number, defaultValue: number): void;\r\n\r\n    /**\r\n     * @param {number} voffset\r\n     * @param {number} value\r\n     * @param {number} defaultValue\r\n     */\r\n    addFieldFloat64(voffset: number, value: number, defaultValue: number): void;\r\n\r\n    /**\r\n     * @param {number} voffset\r\n     * @param {flatbuffers.Offset} value\r\n     * @param {flatbuffers.Offset} defaultValue\r\n     */\r\n    addFieldOffset(voffset: number, value: Offset, defaultValue: Offset): void;\r\n\r\n    /**\r\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\r\n     *\r\n     * @param {number} voffset\r\n     * @param {flatbuffers.Offset} value\r\n     * @param {flatbuffers.Offset} defaultValue\r\n     */\r\n    addFieldStruct(voffset: number, value: Offset, defaultValue: Offset): void;\r\n\r\n    /**\r\n     * Structures are always stored inline, they need to be created right\r\n     * where they're used.  You'll get this assertion failure if you\r\n     * created it elsewhere.\r\n     *\r\n     * @param {flatbuffers.Offset} obj The offset of the created object\r\n     */\r\n    nested(obj: Offset): void;\r\n\r\n    /**\r\n     * Should not be creating any other object, string or vector\r\n     * while an object is being constructed\r\n     */\r\n    notNested(): void;\r\n\r\n    /**\r\n     * Set the current vtable at `voffset` to the current location in the buffer.\r\n     *\r\n     * @param {number} voffset\r\n     */\r\n    slot(voffset: number): void;\r\n\r\n    /**\r\n     * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\r\n     */\r\n    offset(): Offset;\r\n\r\n    /**\r\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\r\n     * the end of the new buffer (since we build the buffer backwards).\r\n     *\r\n     * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\r\n     * @returns {flatbuffers.ByteBuffer} A new byte buffer with the old data copied\r\n     * to it. The data is located at the end of the buffer.\r\n     */\r\n    static growByteBuffer(bb: ByteBuffer): ByteBuffer;\r\n\r\n    /**\r\n     * Adds on offset, relative to where it will be written.\r\n     *\r\n     * @param {flatbuffers.Offset} offset The offset to add\r\n     */\r\n    addOffset(offset: Offset): void;\r\n\r\n    /**\r\n     * Start encoding a new object in the buffer.  Users will not usually need to\r\n     * call this directly. The FlatBuffers compiler will generate helper methods\r\n     * that call this method internally.\r\n     *\r\n     * @param {number} numfields\r\n     */\r\n    startObject(numfields: number): void;\r\n\r\n    /**\r\n     * Finish off writing the object that is under construction.\r\n     *\r\n     * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\r\n     */\r\n    endObject(): Offset;\r\n\r\n    /**\r\n     * @param {flatbuffers.Offset} root_table\r\n     * @param {string=} file_identifier\r\n     */\r\n    finish(root_table: Offset, file_identifier?: string): void;\r\n\r\n    /**\r\n     * This checks a required field has been set in a given table that has\r\n     * just been constructed.\r\n     *\r\n     * @param {flatbuffers.Offset} table\r\n     * @param {number} field\r\n     */\r\n    requiredField(table: Offset, field: number): void;\r\n\r\n    /**\r\n     * Start a new array/vector of objects.  Users usually will not call\r\n     * this directly. The FlatBuffers compiler will create a start/end\r\n     * method for vector types in generated code.\r\n     *\r\n     * @param {number} elem_size The size of each element in the array\r\n     * @param {number} num_elems The number of elements in the array\r\n     * @param {number} alignment The alignment of the array\r\n     */\r\n    startVector(elem_size: number, num_elems: number, alignment: number): void;\r\n\r\n    /**\r\n     * Finish off the creation of an array and all its elements. The array must be\r\n     * created with `startVector`.\r\n     *\r\n     * @returns {flatbuffers.Offset} The offset at which the newly created array\r\n     * starts.\r\n     */\r\n    endVector(): Offset;\r\n\r\n    /**\r\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\r\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\r\n     *\r\n     * @param {string|Uint8Array} s The string to encode\r\n     * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\r\n     */\r\n    createString(s: string|Uint8Array): Offset;\r\n\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////\r\n  \r\n\r\n  class ByteBuffer {\r\n\r\n    /**\r\n     * @constructor\r\n     * @param {Uint8Array} bytes\r\n     */\r\n    constructor(bytes: Uint8Array);\r\n\r\n    /**\r\n     * @param {number} byte_size\r\n     * @returns {flatbuffers.ByteBuffer}\r\n     */\r\n    static allocate(byte_size: number): ByteBuffer;\r\n\r\n    /**\r\n     * @returns {Uint8Array}\r\n     */\r\n    bytes(): Uint8Array;\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    position(): number;\r\n\r\n    /**\r\n     * @param {number} position\r\n     */\r\n    setPosition(position: number): void;\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    capacity(): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    readInt8(offset: number): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    readUint8(offset: number): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    readInt16(offset: number): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    readUint16(offset: number): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    readInt32(offset: number): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    readUint32(offset: number): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {flatbuffers.Long}\r\n     */\r\n    readInt64(offset: number): Long;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {flatbuffers.Long}\r\n     */\r\n    readUint64(offset: number): Long;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    readFloat32(offset: number): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    readFloat64(offset: number): number;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @param {number} value\r\n     */\r\n    writeInt8(offset: number, value: number): void;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @param {number} value\r\n     */\r\n    writeInt16(offset: number, value: number): void;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @param {number} value\r\n     */\r\n    writeInt32(offset: number, value: number): void;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @param {flatbuffers.Long} value\r\n     */\r\n    writeInt64(offset: number, value: Long): void;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @param {number} value\r\n     */\r\n    writeFloat32(offset: number, value: number): void;\r\n\r\n    /**\r\n     * @param {number} offset\r\n     * @param {number} value\r\n     */\r\n    writeFloat64(offset: number, value: number): void;\r\n\r\n    /**\r\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\r\n     * field is not present.\r\n     *\r\n     * @param {number} bb_pos\r\n     * @param {number} vtable_offset\r\n     * @returns {number}\r\n     */\r\n    __offset(bb_pos: number, vtable_offset: number): number;\r\n\r\n    /**\r\n     * Initialize any Table-derived type to point to the union at the given offset.\r\n     *\r\n     * @param {flatbuffers.Table} t\r\n     * @param {number} offset\r\n     * @returns {flatbuffers.Table}\r\n     */\r\n    __union(t: Table, offset: number): Table;\r\n\r\n    /**\r\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\r\n     * This allocates a new string and converts to wide chars upon each access.\r\n     *\r\n     * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\r\n     * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\r\n     * and from UTF-16 when the data will just be packaged back up in another\r\n     * FlatBuffer later on.\r\n     *\r\n     * @param {number} offset\r\n     * @param {flatbuffers.Encoding=} optionalEncoding Defaults to UTF16_STRING\r\n     * @returns {string|Uint8Array}\r\n     */\r\n    __string(offset: number, optionalEncoding?: Encoding): string|Uint8Array;\r\n\r\n    /**\r\n     * Retrieve the relative offset stored at \"offset\"\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    __indirect(offset: number): number;\r\n\r\n    /**\r\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\r\n     *\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    __vector(offset: number): number;\r\n\r\n    /**\r\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\r\n     *\r\n     * @param {number} offset\r\n     * @returns {number}\r\n     */\r\n    __vector_len(offset: number): number;\r\n\r\n    /**\r\n     * @param {string} ident\r\n     * @returns {boolean}\r\n     */\r\n    __has_identifier(ident: string): boolean;\r\n\r\n  }\r\n\r\n}"
}